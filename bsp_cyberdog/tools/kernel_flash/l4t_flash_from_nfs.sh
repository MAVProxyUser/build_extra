#!/bin/bash

# Copyright (c) 2020-2021, NVIDIA CORPORATION. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# Usage: ./l4t_flash_from_nfs.sh
# This script flashes the target from the Network File Systems using the images
# inside the flash package generated by l4t_create_flash_image_in_nfs
#

set -e


function cleanup
{
	for f in "${LOG_DIR}"/*
	do
		if ! [ -f "${f}" ]; then
			break
		fi
		print_log "$(cat "${f}")"
	done

	if [ "${qspi_only}" = "0" ] && [ "${host_mode}" = "0" ] && [ "${external_only}" = "0" ]; then
		if [ -f "/sys/block/${mmcblk0boot0}/force_ro" ]; then
			echo 1 > "/sys/block/${mmcblk0boot0}/force_ro"
		fi
		if [ -f "/sys/block/${mmcblk0boot1}/force_ro" ]; then
			echo 1 > "/sys/block/${mmcblk0boot1}/force_ro"
		fi
	fi
}

function print_at_end
{
	local temp_file
	temp_file=$(mktemp "${LOG_DIR}/XXX")
	echo -e "${@}" > "${temp_file}"
}

function usage
{
	echo -e "
Usage: $0 [--external-only | --host-mode | --qspi-only | --no-reboot]
Where,
	--external-only             Skip flashing the internal storage
	--qspi-only                 Flashing the qdpi storage only
	--host-mode                 Flashing options used when not running from NFS
	--no-reboot                 Don't reboot after finishing
This script flashes the target using the kernel on NFS using the images
inside the flash package generated by l4t_create_flash_image_in_nfs

	"; echo;
	exit 1
}

function print_log
{
	local end=$SECONDS
	local duration=$(( end - START ))
	echo -e "[ ${duration}]: ${SCRIPT_NAME}: ${*}"
}

function get_disk_name
{
	local ext_dev="${1}"
	local disk=
	# ${ext_dev} could be specified as a partition; therefore, removing the
	# number if external storage device is scsi, otherwise, remove the trailing
	# "p[some number]" here
	if [[ "${ext_dev}" = sd* ]]; then
		disk=${ext_dev%%[0-9]*}
	else
		disk="${ext_dev%p*}"
	fi
	echo "${disk}"
}

function is_internal_device()
{
   if [ "${1}" = "${SDCARD_STORAGE_DEVICE}" ] ||
      [ "${1}" = "${SDMMC_USER_DEVICE}" ]; then
          return 0;
   fi
   return 1;
}

function is_gpt_support_device()
{
	if [ "${1}" = "${SDCARD_STORAGE_DEVICE}" ] ||
      [ "${1}" = "${SDMMC_USER_DEVICE}" ] ||
	  [ "${1}" =  "${EXTERNAL_STORAGE_DEVICE}" ]; then
          return 0;
   fi
   return 1;
}

function is_not_qspi()
{
	if [ "${1}" = "${SDMMC_BOOT_DEVICE}" ] \
		|| [ "${1}" = "${SDMMC_USER_DEVICE}" ] \
		|| [ "${1}" = "${SDCARD_STORAGE_DEVICE}" ] \
		|| [ "${1}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
          return 0;
   fi
   return 1;
}

function get_value_from_PT_table() {
	# Usage:
	#	get_value_from_PT_table {__pt_name} \
	#	{__pt_node} \
	#	{__pt_file} \
	local __XMLLINT_BIN="";
	local __pt_name="${1}";
	local __pt_node="${2}";
	local __pt_file="${3}";
	local __node_val="";

	# Check xmllint
	if [ -f "/usr/bin/xmllint" ]; then
		__XMLLINT_BIN="/usr/bin/xmllint";
	else
		if [ -z "${__XMLLINT_BIN}" ]; then
			print_at_end "ERROR xmllint not found! To install - please run: \"sudo apt-get install \
libxml2-utils\""
			exit 1
		fi;
	fi;

	# Get node value
	__node_val="$(${__XMLLINT_BIN} --xpath "/partition_layout/device/partition[@name='${__pt_name}']/${__pt_node}/text()" "${__pt_file}" 2>/dev/null)";
	__node_val=$(echo "${__node_val}" | xargs echo);

	echo "${__node_val}";
}

function erase_spi
{
	flash_erase "${1}" 0 0
}

function is_sparse_image
{
	[ "$(xxd -p -s 0f -l 4 "${1}")" = "${SPARSE_FILE_MAGIC}" ]
}

function is_tar_archive
{
	file "${file_image}" | grep -q 'tar archive'
}

function is_spi_flash
{
	if [ ! -f "${FLASH_INDEX_FILE}" ];then
		print_at_end "Error: ${FLASH_INDEX_FILE} is not found"
		exit 1
	fi

	readarray index_array < "${FLASH_INDEX_FILE}"
	echo "Flash index file is ${FLASH_INDEX_FILE}"

	lines_num=${#index_array[@]}
	echo "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	echo "max_index=${max_index}"

	for i in $(seq 0 ${max_index})
	do
		local item="${index_array[$i]}"

		# Try to search for a device that has type SPI flash(3)
		local device_type
		device_type=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		if [ "${device_type}" = "${SPI_DEVICE}" ];then
			return 0
		fi
	done
	return 1
}

function write_to_spi
{

	if [ ! -f "${FLASH_INDEX_FILE}" ];then
		print_at_end "Error: ${FLASH_INDEX_FILE} is not found"
		exit 1
	fi

	readarray index_array < "${FLASH_INDEX_FILE}"
	echo "Flash index file is ${FLASH_INDEX_FILE}"

	lines_num=${#index_array[@]}
	echo "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	echo "max_index=${max_index}"

	for i in $(seq 0 ${max_index})
	do
		local item="${index_array[$i]}"
		# break if device type is other than SPI flash(3) as only generating
		# image for SPI flash(3)
		local device_type
		device_type=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		if [ "${device_type}" != "${SPI_DEVICE}" ];then
			echo "Reach the end of the SPI device"
			break
		fi

		# fill the partition image into the SPI image
		if ! write_to_spi_partition "${item}" /dev/mtd0; then
			exit 1
		fi
	done

	return 0
}

function write_to_spi_partition
{
	local item="${1}"
	local spi_image="${2}"
	local part_name
	local file_name
	local start_offset
	local file_size
	local sha1_chksum
	part_name=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 3)
	file_name=$(echo "${item}" | cut -d, -f 5 | sed 's/^ //g' -)
	start_offset=$(echo "${item}" | cut -d, -f 3 | sed 's/^ //g' -)
	file_size=$(echo "${item}" | cut -d, -f 6 | sed 's/^ //g' -)
	sha1_chksum=$(echo "${item}" | cut -d, -f 8 | sed 's/^ //g' -)

	if [ -z "${file_name}" ];then
		print_log "Warning: skip writing ${part_name} partition as no image is \
specified"
		return 0
	fi

	echo "Writing ${file_name} (parittion: ${part_name}) into ${spi_image}"

	local part_image_file="${COMMON_IMAGES_DIR}/${file_name}"
	if [ ! -f "${part_image_file}" ];then
		print_log "Error: image for partition ${part_name} is not found at \
${part_image_file}"
		return 1
	fi

	sha1_verify "${part_image_file}" "${sha1_chksum}"

	echo "Writing ${part_image_file} (${file_size} bytes) into "\
		"${spi_image}:${start_offset}"
	if ! mtd_debug write "${spi_image}" "${start_offset}" "${file_size}" \
		"${part_image_file}"; then
		print_log "Writing ${part_image_file} (${file_size} bytes) into \
${spi_image}:${start_offset} failed"
		return 1
	fi
	# Write BCT redundancy
	# BCT image should be written in multiple places: (Block 0, Slot 0), (Block
	# 0, Slot 1) and (Block 1, Slot 0). In this case, block size is 32KB and the
	# slot size is 4KB, so the BCT image should be written at the place where
	# offset is 4096 and 32768
	if [ "${part_name}" = "BCT" ]; then
		# Block 0, Slot 1
		start_offset=4096
		echo "Writing ${part_image_file} (${file_size} bytes) into " \
			"${spi_image}:${start_offset}"
		if ! mtd_debug write "${spi_image}" "${start_offset}" "${file_size}" \
		"${part_image_file}"; then
			print_log "Writing ${part_image_file} (${file_size} bytes) into \
${spi_image}:${start_offset} failed"
			return 1
		fi

		# Block 1, Slot 0
		start_offset=32768
		echo "Writing ${part_image_file} (${file_size} bytes) into " \
		"${spi_image}:${start_offset}"
		if ! mtd_debug write "${spi_image}" "${start_offset}" "${file_size}" \
			"${part_image_file}"; then
			print_log "Writing ${part_image_file} (${file_size} bytes) into \
${spi_image}:${start_offset} failed"
			return 1
		fi
	fi
}

# Verify sha1 checksum for image
# @file_image: file for caculating check sum
# @sha1chksum: sha1 check sum
function sha1_verify
{
	local file_image="${1}"
	local sha1_chksum="${2}"

	if [ -z "${sha1_chksum}" ];then
		print_log "Passed-in sha1 checksum is NULL"
		return 1
	fi

	if [ ! -f "${file_image}" ];then
		print_log "$file_image is not found !!!"
		return 1
	fi

	local sha1_chksum_gen
	sha1_chksum_gen=$(sha1sum "${file_image}" | cut -d\  -f 1)
	if [ "${sha1_chksum_gen}" = "${sha1_chksum}" ];then
		echo "Sha1 checksum matched for ${file_image}"
		return 0
	else
		print_log "Sha1 checksum does not match (${sha1_chksum_gen} \
!= ${sha1_chksum}) for ${file_image}"
		return 1
	fi
}

# This function read and write partitions using the infile and outfile name
# ,the infile offset and theout file offset, and the total size given.
function read_write_file
{
	local infile="${1}"
	local outfile="${2}"
	local inoffset="${3}"
	local outoffset="${4}"
	local size="${5}"

	if [ ! -e "${infile}" ];then
		print_log "Input file ${infile} is not found"
		return 1
	fi

	if [ "${size}" -eq 0 ];then
		print_log "The size of bytes to be read is ${size}"
		return 1
	fi

	local inoffset_align_K=$((inoffset % K_BYTES))
	local outoffset_align_K=$((outoffset % K_BYTES))
	if [ "${inoffset_align_K}" -ne 0 ] || [ "${outoffset_align_K}" -ne 0 ];then
		echo "Offset is not aligned to K Bytes, no optimization is applied"
		echo "dd if=${infile} of=${outfile} bs=1 skip=${inoffset} "\
			"seek=${outoffset} count=${size}"
		dd if="${infile}" of="${outfile}" bs=1 skip="${inoffset}" \
			seek="${outoffset}" count="${size}"
		return 0
	fi

	local block=$((size / K_BYTES))
	local remainder=$((size % K_BYTES))
	local inoffset_blk=$((inoffset / K_BYTES))
	local outoffset_blk=$((outoffset / K_BYTES))

	echo "${size} bytes from ${infile} to ${outfile}: 1KB block=${block} \
remainder=${remainder}"

	if [ ${block} -gt 0 ];then
		echo "dd if=${infile} of=${outfile} bs=1K skip=${inoffset_blk} "\
			"seek=${outoffset_blk} count=${block}"
		dd if="${infile}" of="${outfile}" bs=1K skip="${inoffset_blk}" \
			seek="${outoffset_blk}" count="${block}" conv=notrunc
		sync
	fi
	if [ ${remainder} -gt 0 ];then
		local block_size=$((block * K_BYTES))
		local outoffset_rem=$((outoffset + block_size))
		local inoffset_rem=$((inoffset + block_size))
		echo "dd if=${infile} of=${outfile} bs=1 skip=${inoffset_rem} "\
			"seek=${outoffset_rem} count=${remainder}"
		dd if="${infile}" of="${outfile}" bs=1 skip="${inoffset_rem}" \
			seek="${outoffset_rem}" count="${remainder}" conv=notrunc
		sync
	fi
	return 0
}

function flash_partition
{
	local file_name="${1}"
	local part_name="${2}"
	local start_offset="${3}"
	local file_size="${4}"
	local attributes="${5}"
	local sha1_chksum="${6}"
	local device="${7}"
	local tmp_file=/tmp/tmp.img
	local active_dir
	active_dir=$(dirname "${FLASH_INDEX_FILE}")
	local file_image=${active_dir}/${file_name}
	local sha1_chksum_gen=
	local res=0
	local tmp_size=0

	if [ ! -f "${file_image}" ];then
		file_image=${COMMON_IMAGES_DIR}/${file_name}
	fi

	if is_sparse_image "${file_image}"; then
		if [ -n "${device}" ];then
			local device_name
			IFS='-' read -r -a attribute <<< "${attributes}"
			entry_id="${attribute[2]}"
			device_name=$(basename "${device}")
			write_sparse_image "/dev/$(get_partition "${device_name}" "${entry_id}")" "${file_image}"
			return 0
		fi
	fi

	if [ "${VERIFY_WRITE}" -eq 1 ];then
		# skip verifying SMD/SMD_b/kernel-bootctrl/kernel-bootctrl_b
		# paritions as the sha1 cheksum in the index file is generated
		# from the dummy image file other than the exact image file
		if [ "${part_name}" != "SMD" ] \
			&& [ "${part_name}" != "SMD_b" ] \
			&& [ "${part_name}" != "kernel-bootctrl" ] \
			&& [ "${part_name}" != "kernel-bootctrl_b" ];then
			if ! sha1_verify "${file_image}" "${sha1_chksum}"; then
				return 1
			fi
		fi

		# verify whether this partition has been writen
		rm -f "${tmp_file}"
		if [ -n "${device}" ];then
			if ! read_write_file "${device}" "${tmp_file}" \
				"${start_offset}" 0 "${file_size}";then
				print_log "Failed to read ${file_size} bytes from \
${device}:${start_offset} to ${tmp_file}"
				return 1
			fi
		else
			tmp_size=$((SDMMC_BOOT0_SIZE - start_offset))
			dd if="/dev/${mmcblk0boot0}" of="${tmp_file}" skip="${start_offset}" \
				bs=1 count="${tmp_size}"
			tmp_size=$((file_size - tmp_size))
			dd if="/dev/${mmcblk0boot1}" bs=1 count="${tmp_size}" >> "${tmp_file}"
		fi
		sync
		sha1_chksum_gen=$(sha1sum "${tmp_file}" | cut -d\  -f 1)
		if [ "${sha1_chksum_gen}" = "${sha1_chksum}" ];then
			print_log "Partition ${part_name} has been updated, skip writing"
			return 0
		fi
	fi

	# write image
	if [ -n "${device}" ];then
		if ! read_write_file "${file_image}" "${device}" 0 \
			"${start_offset}" "${file_size}";then
			print_log "Failed to write ${file_size} bytes from ${file_image} to \
${device}:${start_offset}"
			return 1
		fi
	else
		tmp_size=$((SDMMC_BOOT0_SIZE - start_offset))
		echo "dd if=${file_image} of=${device} seek=${start_offset} bs=1"\
			" count=${tmp_size} conv=notrunc"
		dd if="${file_image}" of="/dev/${mmcblk0boot0}" seek="${start_offset}" bs=1 \
			count="${tmp_size}" conv=notrunc

		dd if="${file_image}" of="/dev/${mmcblk0boot1}" bs=1 skip="${tmp_size}" \
			conv=notrunc
	fi
	sync

	if [ "${VERIFY_WRITE}" -eq 1 ];then
		rm -f "${tmp_file}"
		# verify writing
		if [ -n "${device}" ];then
			if ! read_write_file "${device}" "${tmp_file}" \
				"${start_offset}" 0 "${file_size}"; then
				print_log "Failed to read ${file_size} bytes from \
${device}:${start_offset} to ${tmp_file}"
				return 1
			fi
		else
			tmp_size=$((SDMMC_BOOT0_SIZE - start_offset))
			echo "dd if=/dev/${mmcblk0boot0} of=${tmp_file} skip=${start_offset} "\
				"bs=1 count=${tmp_size}"
			dd if="/dev/${mmcblk0boot0}" of="${tmp_file}" skip="${start_offset}" \
				bs=1 count="${tmp_size}"
			tmp_size=$((file_size - tmp_size))
			echo "dd if=/dev/${mmcblk0boot1} bs=1 count=${tmp_size} >>${tmp_file}"
			dd if="/dev/${mmcblk0boot1}" bs=1 count="${tmp_size}" >> "${tmp_file}"
		fi

		# For SMD/SMD_B and kernel-bootctrl/kernel-bootctrl_b, the
		# sha1 chksum needs to be re-generated from the exact image file
		if [ "${part_name}" = "SMD" ] \
			|| [ "${part_name}" = "SMD_b" ] \
			|| [ "${part_name}" = "kernel-bootctrl" ] \
			|| [ "${part_name}" = "kernel-bootctrl_b" ];then
			echo "Re-generate sha1sum for the image ${file_image}"
			sha1_chksum=$(sha1sum "${file_image}" | cut -d\  -f 1)
		fi

		sha1_verify "${tmp_file}" "${sha1_chksum}"
	fi
	return "${?}"
}

flash_sdmmc_boot_partition()
{
	local start_offset=$3
	local file_size=$4
	local sdmmc_device=
	local args=("$@")
	local end_offset=

	start_offset=$((start_offset))
	file_size=$((file_size))
	end_offset=$((start_offset + file_size))
	if [ ${start_offset} -ge "${SDMMC_BOOT0_SIZE}" ]; then
		sdmmc_device=/dev/${mmcblk0boot1}
		start_offset=$((start_offset - SDMMC_BOOT0_SIZE))
		args[2]=${start_offset}
	elif [ ${end_offset} -le "${SDMMC_BOOT0_SIZE}" ]; then
		sdmmc_device=/dev/${mmcblk0boot0}
	else
		# partition cross over mmcblk0boot0 and mmcblk0boot1 and
		# it should be handled in special way
		sdmmc_device=""
	fi

	flash_partition "${args[@]}" "${sdmmc_device}"
	return $?
}

function flash_sdmmc_user_partition
{
	local sdmmc_device=/dev/${mmcblk0}

	flash_partition "$@" "${sdmmc_device}"
	return "${?}"
}

function flash_extdev_partition
{
	# external_device is going to be generated by
	# l4t_create_flash_image_in_nfs.sh
	local disk=

	disk="/dev/$(get_disk_name "${external_device}")"
	flash_partition "$@" "${disk}"
	return "${?}"
}

function get_partition
{
	local device="${1}"
	local count="${2}"
	local partition
	local disk
	if [[ "${device}" = sd* ]]; then
		disk=${device%%[0-9]*}
		partition="${disk}${count}"
	else
		disk="${device%p*}"
		partition="${disk}p${count}"
	fi
	if [ -z "${count}" ] || [ "${count}" -eq 0 ]; then
		echo "${disk}"
		return
	fi
	echo "${partition}"
}

# function to write a sparse image to a dev node
# first argument is the destination dev node, second argument is the file to write
function write_sparse_image
{
	# sparse file
	if [ "${host_mode}" = "0" ]; then
		echo "blkdiscard ${1}"
		blkdiscard "${1}"
	fi

	if ! command -v simg2img &> /dev/null; then
		print_at_end "ERROR simg2img not found! To install - please run: \"sudo apt-get install \
simg2img\" or \"sudo apt-get install android-tools-fsutils\""
		exit 1
	fi
	echo "simg2img ${2} ${1}"
	simg2img "${2}" "${1}"
	sync
	return
}

function do_write_storage
{
	local item="${1}"
	local count="${2}"
	local device_type
	local part_name
	local file_name
	local start_offset
	local file_size
	local attributes
	local sha1_chksum
	local partition
	local start_sector
	local disk
	device_type=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 1)
	part_name=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 3)
	file_name=$(echo "${item}" | cut -d, -f 5 | sed 's/^ //g' -)
	start_offset=$(echo "${item}" | cut -d, -f 3 | sed 's/^ //g' -)
	file_size=$(echo "${item}" | cut -d, -f 6 | sed 's/^ //g' -)
	attributes=$(echo "${item}" | cut -d, -f 7 | sed 's/^ //g' -)
	sha1_chksum=$(echo "${item}" | cut -d, -f 8 | sed 's/^ //g' -)
	local res=0

	if [ -z "${file_name}" ];then
		print_log "Warning: skip writing ${part_name} partition as no image \
is specified"
		return 0
	fi

	echo "Writing ${part_name} partition with ${file_name}"
	# if this device is emmc's boot partitions
	if [ "${device_type}" = "${SDMMC_BOOT_DEVICE}" ];then
		if [ "${part_name}" == "secondary_gpt" ];then
			start_offset=$((start_offset - SDMMC_BOOT0_SIZE))
		fi
		flash_sdmmc_boot_partition "${file_name}" "${part_name}" \
			"${start_offset}" "${file_size}" "${attributes}" "${sha1_chksum}"
		res="${?}"
		if [ "${res}" -ne 0 ];then
			return "${res}"
		fi

	 # if this device is emmc's user partitions
	elif is_internal_device "${device_type}" ;then
		if [ -n "${count}" ] && [ "${count}" -ne 0 ]; then
			partition=$(get_partition "${mmcblk0}" "${count}")
			pblksz=$(blockdev --getpbsz "/dev/${partition}")
			start_sector=$(cat "/sys/block/${mmcblk0}/${partition}/start")
			if [ $((start_sector * pblksz)) -ne 0 ]; then
				start_offset=$((start_sector * pblksz))
			fi
		fi
		flash_sdmmc_user_partition "${file_name}" "${part_name}" \
"${start_offset}" "${file_size}" "${attributes}" "${sha1_chksum}"
		res="${?}"
	elif [ "${device_type}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
		if [ -n "${count}" ]  && [ "${count}" -ne 0 ]; then
			partition=$(get_partition "${external_device}" "${count}")
			pblksz=$(blockdev --getpbsz "/dev/${partition}")
			disk="$(get_disk_name "${external_device}")"
			start_sector=$(cat "/sys/block/${disk}/${partition}/start")

			if [ $((start_sector * pblksz)) -ne 0 ]; then
				start_offset=$((start_sector * pblksz))
			fi
		fi
		flash_extdev_partition "${file_name}" "${part_name}" \
			"${start_offset}" "${file_size}" "${attributes}" "${sha1_chksum}"
		res="${?}"
	else
		print_log "Error: invalid device type ${device_type}"
		return 1
	fi
	echo "Writing ${part_name} partition done"
	return "${res}"
}

function do_write_APP
{
	local item="${1}"
	local external="${2}"
	local count="${3}"
	local file_image
	local sha1_file
	local sha1_chksum=
	local APP_partition=
	local device_type=
	local disk=
	local part_name
	local tool=mkfs.ext4
	local flash_xml_file="${COMMON_IMAGES_DIR}/flash.xml.tmp"
	local extension=""

	device_type=$(echo "$item" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 1)

	part_name=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 3)

	if [ "${device_type}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
		if [ -n "${external_device}" ]; then
			APP_partition=/dev/$(get_partition "${external_device}" "${count}")
			extension=".ext"
		else
			print_log "Error: external device is not specified"
			return 1
		fi
	elif is_internal_device "${device_type}"; then
		APP_partition="/dev/$(get_partition "${mmcblk0}" "${count}")"
	else
		print_log "Error: unsupported device type ${device_type}"
		return 1
	fi

	file_image="${COMMON_IMAGES_DIR}/$(get_value_from_PT_table "${part_name}" \
		"filename" "${flash_xml_file}${extension}")"

	file_image+="${extension}"

	sha1_file="${file_image}.sha1sum"


	if [ ! -f "${file_image}" ];then
		print_log "APP image ${file_image} is not found !!!"
		return 1
	fi

	if [ ! -f "${sha1_file}" ];then
		print_log "Sha1 checksum file ${sha1_file} is not found !!!"
		return 1
	fi

	if [ ! -e "${APP_partition}" ];then
		print_log "APP paritiion ${APP_partition} is not found !!!"
		return 1
	fi

	# verify sha1 checksum
	# sha1_chksum=$(cat "${sha1_file}")
	# if ! sha1_verify "${file_image}" "${sha1_chksum}";then
	# 	return 1
	# fi

	# Using magic to check if this is a sparse file
	if is_sparse_image "${file_image}"; then
		write_sparse_image "${APP_partition}" "${file_image}"
		return 0
	fi

	# Check if this is a tar archive
	if is_tar_archive; then
		# tar file
		# format APP partition and mount it
		echo "Formatting APP partition ${APP_partition} ..."
		"${tool}" -F "${APP_partition}"
		echo "Formatting APP parition done"
		tmp_dir=$(mktemp -d -t ci-XXXXXXXXXX)

		if ! mount "${APP_partition}" "${tmp_dir}"; then
			print_log "Failed to mount APP partition ${APP_partition}"
			return 1
		fi

		# decompress APP image into APP partition
		echo "Formatting APP partition ${APP_partition} ..."
		echo "tar --xattrs -xpf ${file_image} " "${COMMON_TAR_OPTIONS[@]}" " -C "\
			"${tmp_dir}"
		if ! tar --xattrs -xpf "${file_image}" "${COMMON_TAR_OPTIONS[@]}" \
			-C "${tmp_dir}"; then
			print_log "Failed to decompress APP image into ${APP_partition}"
			# umount APP parition
			umount "${tmp_dir}"
			rm -rf "${tmp_dir}"
			return 1
		fi
		sync

		# umount APP parition
		umount "${tmp_dir}"
		rm -rf "${tmp_dir}"
		return 0
	fi

	# raw image. Simply dd to the destination
	dd if="${file_image}" of="${APP_partition}"
	sync
}

function create_gpt
{
	local device_type=
	local part_name=
	local start_offset=
	local part_size=
	local res=0
	local GPT_EXIST=false
	local index_file="${1}"
	local external="1"
	local disk=
	local size=
	local pblksz=
	local item


	if [ -z "${index_file}" ]; then
		index_file="${FLASH_INDEX_FILE}"
		external=""
	fi

	echo "Active index file is ${index_file}"
	readarray ACTIVE_INDEX_ARRAY < "${index_file}"


	lines_num=${#ACTIVE_INDEX_ARRAY[@]}
	echo "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	echo "max_index=${max_index}"

	local entry_id=0
	local shouldExpandLastPart=0
	local expandedPartId=0


	# The GPT must be the first partition flashed, so this block ensures that
	# the GPT exists and is flashed first.

	for i in $(seq 0 ${max_index})
	do
		item=${ACTIVE_INDEX_ARRAY[$i]}

		part_name=$(echo "$item" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 3)

		device_type=$(echo "$item" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		start_offset=$(echo "${item}" | cut -d, -f 3 | sed 's/^ //g' -)
		part_size=$(echo "${item}" | cut -d, -f 4 | sed 's/^ //g' -)
		IFS='-' read -r -a attribute <<< "$(echo "${item}" | cut -d, -f 7 | sed 's/^ //g' -)"


		if is_gpt_support_device "${device_type}"; then
			# device type equals 1 indicates internal user emmc storage
			# device type equals 9 indicates external storage

			disk="/dev/${mmcblk0}"
			if [ "${device_type}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
				# This is an external storage device so try to find the name of
				# the devnode here.
				disk="/dev/$(get_disk_name "${external_device}")"
			fi

			if [ -z "${attribute[2]}" ]; then
				entry_id="$((entry_id + 1))"
			else
				entry_id="${attribute[2]}"
			fi
			if [ "${part_name}" = "primary_gpt" ]; then
				echo -n "writing item=${item}"
				# This recreates the mbr and clears gpt. In the case where mbr
				# is invalid or does not exist, this will help partx read gpt table
				parted -s "${disk}" mklabel gpt
				do_write_storage "${item}" ""
				if ! partprobe "${disk}"; then
					 print_at_end "Error: partprobe failed. This indicates that:\n" \
						"-   the xml indicates the gpt is larger than the device storage\n" \
						"-   the xml might be invalid\n" \
						"-   the device might have a problem.\n" \
						"Please make correction."
					exit 1
				fi
				GPT_EXIST=true
				entry_id=0
				continue
			elif [ "${part_name}" = "secondary_gpt" ]; then
				local size=
				size=$(blockdev --getsize64 "${disk}")
				do_write_storage "${item}" ""
				if [ $((start_offset + part_size)) -gt "${size}" ]; then
					print_at_end "Error: the ${disk} size $((start_offset + part_size)) set in \
partition layout xml is greater than the ${disk} actual size ${size}. Please make correction"
					exit 1
				elif [ $((start_offset + part_size)) -lt "${size}" ]; then
					print_at_end "The device size indicated in the partition \
layout xml is smaller than the actual size. This utility will try to fix the GPT."
					set +e
					echo -e "Fix\nFix" | parted ---pretend-input-tty "${disk}" print
					if [ "${shouldExpandLastPart}" = "1" ]; then
						print_log "Expanding last partition to fill the storage device"
						parted -s "${disk}" "resizepart ${expandedPartId} 100%"
					fi
					set -e
				fi
			elif [ "${attribute[0]}" = "expand" ]; then
				shouldExpandLastPart="1"
				expandedPartId="${entry_id}"
			fi

		fi
	done

	# if GPT does not exist exit.
	if [ "${GPT_EXIST}" != true ]; then
		print_at_end "The GPT does not exist in the index file"
		exit 1
	fi
}

function write_to_storage
{
	local device_type=
	local part_name=
	local start_offset=
	local part_size=
	local res=0
	local GPT_EXIST=false
	local index_file="${1}"
	local external="1"
	local disk=
	local size=
	local pblksz=
	local item


	if [ -z "${index_file}" ]; then
		index_file="${FLASH_INDEX_FILE}"
		external=""
	fi

	echo "Active index file is ${index_file}"
	readarray ACTIVE_INDEX_ARRAY < "${index_file}"


	lines_num=${#ACTIVE_INDEX_ARRAY[@]}
	echo "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	echo "max_index=${max_index}"

	local entry_id=0

	for i in $(seq 0 ${max_index})
	do
		item=${ACTIVE_INDEX_ARRAY[$i]}
		part_name=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 3)

		device_type=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		IFS='-' read -r -a attribute <<< "$(echo "${item}" | cut -d, -f 7 | sed 's/^ //g' -)"

		if is_not_qspi "${device_type}"; then
			echo -n "writing item=${item}"

			if [ "${part_name}" = "primary_gpt" ]; then
				entry_id=0
				continue
			elif [ "${part_name}" = "secondary_gpt" ] || [ "${part_name}" = "master_boot_record" ]; then
				# skip as we have already put these in
				continue
			fi
			if [ -z "${attribute[2]}" ]; then
				entry_id="$((entry_id + 1))"
			else
				entry_id="${attribute[2]}"
			fi
			# Starting writing partitions
			if [ "${part_name}" = "APP" ] || [ "${part_name}" = "APP_b" ] ; then
				if ! do_write_APP "${item}" "${external}" "${entry_id}"; then
					print_at_end "Failed to write to ${part_name}"
					exit 1
				fi
			else
				if ! do_write_storage "${item}" "${entry_id}"; then
					print_at_end "Failed to write to ${part_name}"
					exit 1
				fi
			fi
		elif [ "${device_type}" = "${SPI_DEVICE}" ]; then
			continue
		fi
	done
}

function flash_qspi
{
	if [ "${host_mode}" = "0" ] && [ "${external_only}" = "0" ] && is_spi_flash; then
		print_log "Starting to flash to qspi"
		erase_spi /dev/mtd0
		write_to_spi
		print_log "Successfully flash the qspi"
	fi
}

function create_gpt_emmc
{
	if [ "${qspi_only}" = "0" ] && [ "${external_only}" = "0" ] && [ -f "${FLASH_INDEX_FILE}" ]; then
		print_log "Starting to create gpt for emmc"
		create_gpt
		print_log "Successfully create gpt for emmc"
	fi
}

function create_gpt_extdev
{
	if [ "${qspi_only}" = "0" ] && [ -f "${FLASH_INDEX_FILE}.ext" ]; then
		print_log "Starting to create gpt for external device"
		create_gpt "${FLASH_INDEX_FILE}.ext"
		print_log "Successfully create gpt for external device"
	fi
}

function flash_emmc
{
	if [ "${qspi_only}" = "0" ] && [ "${external_only}" = "0" ] && [ -f "${FLASH_INDEX_FILE}" ]; then
		print_log "Starting to flash to emmc"
		write_to_storage
		print_log "Successfully flash the emmc"
	fi
}

function flash_extdev
{
	if [ "${qspi_only}" = "0" ] && [ -f "${FLASH_INDEX_FILE}.ext" ]; then
		print_log "Starting to flash to external device"
		write_to_storage "${FLASH_INDEX_FILE}.ext"
		print_log "Successfully flash the external device"
	fi
}


trap cleanup EXIT

VERIFY_WRITE=0
external_only=0
host_mode=0
qspi_only=0
no_reboot=0

COMMON_TAR_OPTIONS=("--checkpoint=10000" \
	"--warning=no-timestamp" \
	"--numeric-owner")
K_BYTES=1024
COMMON_IMAGES_DIR=$(cd "$(dirname "${0}")" && pwd);
SCRIPT_NAME="l4t_flash_from_nfs"
readonly SDMMC_USER_DEVICE="1"
readonly SDCARD_STORAGE_DEVICE="6"
readonly SDMMC_BOOT_DEVICE="0"
readonly EXTERNAL_STORAGE_DEVICE="9"
readonly SPI_DEVICE="3"
readonly SPARSE_FILE_MAGIC="3aff26ed"
mmcblk0boot0="${MMCBLKB0:-mmcblk0boot0}"
mmcblk0boot1="${MMCBLKB1:-mmcblk0boot1}"
mmcblk0="${MMCBLK0:-mmcblk0}"
if [ -b "/dev/${mmcblk0boot0}" ]; then
	SDMMC_BOOT0_SIZE=$(blockdev --getsize64 "/dev/${mmcblk0boot0}")
fi

opstr+="h-:"
while getopts "${opstr}" OPTION; do
	case $OPTION in
	h) usage; ;;
	-) case ${OPTARG} in
	   external-only) external_only=1; ;;
	   host-mode) host_mode=1; no_reboot=1 ;;
	   qspi-only) qspi_only=1; ;;
	   no-reboot) no_reboot=1; ;;
	   *) usage ;;
	   esac;;
	*)
	   usage
	   ;;
	esac;
done

START="${SECONDS}"

if [ "${USER}" != "root" ]; then
	echo "${0} requires root privilege";
	exit 1;
fi

if [ "${qspi_only}" = "0" ] && [ "${host_mode}" = "0" ] && [ "${external_only}" = "0" ]; then
	if [ -f "/sys/block/${mmcblk0boot0}/force_ro" ]; then
		echo 0 > "/sys/block/${mmcblk0boot0}/force_ro"
	fi
	if [ -f "/sys/block/${mmcblk0boot1}/force_ro" ]; then
		echo 0 > "/sys/block/${mmcblk0boot1}/force_ro"
	fi
fi

FLASH_INDEX_FILE="${COMMON_IMAGES_DIR}/flash.idx"
LOG_DIR=$(mktemp -d)

# Restore the flash configuration
# This file is generated by l4t_create_flash_image_in_nfs.sh
source "${COMMON_IMAGES_DIR}/flash.cfg"
external_device="${EXTERNAL_DEV:-${external_device}}"


# The GPT must be the first partition flashed, so this block ensures that
# the GPT exists and is flashed first. Moreover, creating GPT must be done
# sequentially otherwise horrible things will happen
create_gpt_emmc
create_gpt_extdev

flash_qspi &
qspi=$!
flash_emmc &
emmc=$!
flash_extdev &
extdev=$!

if ! wait "${qspi}"; then
	print_log "Error flashing qspi"
	exit 1
fi

if ! wait "${emmc}"; then
	print_log "Error flashing emmc"
	exit 1
fi

if ! wait "${extdev}"; then
	print_log "Error flashing external device"
	exit 1
fi

wait

print_log "Flashing success"

if [ "${no_reboot}" = "0" ]; then
	print_log "The device is going to reboot in 5 seconds...."
	sleep 5
	reboot now
fi